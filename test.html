<!DOCTYPE html>
<html>
  <head>
    <title>博客线路选择</title>
  </head>
  <body>
    <h3 id="tip">正在为您选择最优线路，请稍等...</h3>
    <p id="output">正在测试</p>
  </body>
  <script>
    // 定义要测试的子域名和优先级
    const subdomains = [
      { name: "主线路", sub: "www", test: "https://www.iuoyt.com"},
      { name: "Github", sub: "github", test: "https://roystert.github.io"},
      { name: "CloudFlare", sub: "cloudflare", test: "https://cloudflare.iuoyt.com"},
      // { name: "Gitee", sub: "gitee", test: "https://roystert.gitee.io/nightyping"},
      // { name: "Zeabur", sub: "zeabur", test: "https://zeabur.iuoyt.com"},
    ];

    // 测试函数，使用fetch来测试连接
    async function testSubdomain(subdomain, minLatency, numTests = 3) {
      try {
        let curMaxLatency = 0;
        let totalLatency = 0;

        for (let i = 0; i < numTests; i++) {
          const tip = "正在测试线路：" + subdomain.name + "，当前测试轮次：" + (i+1) + "/" + numTests;
          console.log(tip);
          document.querySelector("p").innerText = tip;
          const controller = new AbortController();
          const signal = controller.signal;

          const start = performance.now(); // 记录开始时间
          const responsePromise = fetch(subdomain.test, {
            method: "HEAD", // 使用HEAD方法可以减少响应内容的传输，加快测试速度
            signal, // 将signal传递给fetch以支持中止操作
          });

          const timeoutPromise = new Promise((resolve, reject) =>
            setTimeout(() => {
              controller.abort(); // 中止异步操作
              reject(new Error("超过最大延迟时间"));
            }, minLatency)
          );

          const response = await Promise.race([responsePromise, timeoutPromise]);

          // 如果测试还未完成，而是因为超过了最大延迟时间而被中止
          if (response instanceof Error) {
            console.log("[" + subdomain.name + "]线路状态: 不可达, 延迟: 超过最大延迟时间");
            return { reachable: false, latency: -1 };
          }

          await response.text(); // 等待响应内容传输完成
          const end = performance.now(); // 记录结束时间

          const latency = end - start; // 计算延迟时间
          console.log(
            "[" + subdomain.name + "]线路状态" + response.ok + ", 延迟:" + latency + "ms"
          );

          curMaxLatency = latency>curMaxLatency?latency:curMaxLatency;
          totalLatency += latency;
        }

        const averageLatency = totalLatency / numTests;
        console.log("[" + subdomain.name + "]平均延迟:" + averageLatency + "ms");

        return { reachable: true, latency: curMaxLatency };
      } catch (error) {
        console.error("强制中断测试：超过当前最小延迟时间", minLatency,"ms");
        return { reachable: false, latency: -1 };
      }
    }



    // 主函数，用于测试线路并选择最佳线路
    async function blogTestMain() {
      let bestSubdomain = null;
      let minLatency = 1000;

      const url = new URL(window.location);
      let tpUrl = url.searchParams.get('tp')?url.searchParams.get('tp'):'';

      for (const subdomain of subdomains) {
        const { reachable, latency } = await testSubdomain(subdomain, minLatency);
        if (reachable && latency != -1 && latency < minLatency) {
          bestSubdomain = subdomain;
          minLatency = latency;
        }
      }

      if (bestSubdomain) {
        document.querySelector("p").innerText =
          "检测完成，正在重定向到线路："+bestSubdomain.name;
        const url = "https://" + bestSubdomain.sub + ".iuoyt.com" + tpUrl;
        console.log("正在重定向到："+url)
        window.location.href = url; // 自动重定向到最佳线路
      } else {
        // 没有可访问的线路
        document.querySelector("p").innerText =
          "所有线路都无法访问，请稍后再试或联系博客站长！";
      }
    }
    blogTestMain();
  </script>
</html>
